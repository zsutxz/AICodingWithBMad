# Story 1.5: Basic Game Flow and State Management

## Status
Apporved

## Story
**As a** player,
**I want** to start a new game, play through to completion, and see the results,
**so that** I can have a complete gaming session.

## Acceptance Criteria
1. New game can be started from initial state
2. Game progresses through turns until win condition is met
3. Game over screen displays winner and basic statistics
4. Option to return to main menu from game over screen
5. Game state is properly reset when starting new game
6. No memory leaks or state corruption between games

## Tasks / Subtasks
- [ ] Implement complete game flow management (AC: 1, 2)
  - [ ] Create GameStateManager MonoBehaviour for state transitions [Source: docs/game-architecture.md#120]
  - [ ] Implement state pattern with enum for states: MainMenu, Playing, Paused, GameOver [Source: docs/game-architecture.md#323-332]
  - [ ] Connect GameStateManager to WinDetector for victory detection [Source: docs/game-architecture.md#87]
  - [ ] Ensure proper state transitions throughout game lifecycle
- [ ] Create game over screen with results display (AC: 3)
  - [ ] Implement GameOverScreen UI component for results display [Source: docs/game-architecture.md#189]
  - [ ] Display winner information and basic game statistics
  - [ ] Integrate VictoryBanner component for winner announcement [Source: docs/game-architecture.md#212]
  - [ ] Add visual effects for victory celebration
- [ ] Implement navigation between screens (AC: 4)
  - [ ] Create UIManager MonoBehaviour for screen management [Source: docs/game-architecture.md#78]
  - [ ] Implement ScreenManager for handling screen transitions [Source: docs/game-architecture.md#79]
  - [ ] Add "Main Menu" and "Play Again" buttons to game over screen
  - [ ] Ensure proper navigation flow between all screens
- [ ] Create game state persistence and reset system (AC: 5)
  - [ ] Implement GameBoardModel reset functionality for new games
  - [ ] Clear moveHistory and reset currentPlayer when starting new game
  - [ ] Ensure all game systems properly reset to initial state
  - [ ] Test state reset functionality across multiple game sessions
- [ ] Optimize memory management and prevent state corruption (AC: 6)
  - [ ] Implement proper cleanup in OnDestroy() methods
  - [ ] Use object pooling for game pieces to prevent memory fragmentation
  - [ ] Test for memory leaks with multiple game sessions
  - [ ] Validate state integrity after multiple game restarts
- [ ] Integrate audio feedback for game flow (AC: 3)
  - [ ] Connect AudioManager to game state transitions [Source: docs/game-architecture.md#96]
  - [ ] Add victory sound effects when game is won [Source: docs/game-architecture.md#207]
  - [ ] Implement background music transitions between states
  - [ ] Ensure audio feedback enhances the game experience

## Dev Notes
### Previous Story Insights
- WinDetector provides victory detection for game state transitions [Source: docs/stories/1.4.gomoku-win-detection-logic.md#36-39]
- GameBoardModel stores board state and move history for game flow [Source: docs/stories/1.4.gomoku-win-detection-logic.md#58-60]
- VictoryBanner UI component available for winner display [Source: docs/stories/1.4.gomoku-win-detection-logic.md#66]

### Data Models
- GameBoardModel provides 15x15 grid state and move history for game flow [Source: docs/game-architecture.md#81-83]
- GameState ScriptableObject for configurable game state data [Source: docs/game-architecture.md#121]
- GameSettingsModel for audio and UI preferences [Source: docs/game-architecture.md#95-103]

### Component Specifications
- **GameStateManager**: MonoBehaviour for managing overall game state and transitions [Source: docs/game-architecture.md#120]
- **UIManager**: MonoBehaviour for managing all user interface elements [Source: docs/game-architecture.md#78]
- **ScreenManager**: MonoBehaviour for handling screen transitions and navigation [Source: docs/game-architecture.md#79]
- **AudioManager**: MonoBehaviour for managing audio playback and transitions [Source: docs/game-architecture.md#96]
- **GameOverScreen**: UI component for displaying game results and navigation options

### File Locations
- `Assets/_Project/Scripts/GameState/GameStateManager.cs` - Main game state management [Source: docs/game-architecture.md#130]
- `Assets/_Project/Prefabs/GameState/GameStateManager.prefab` - Reusable game state manager [Source: docs/game-architecture.md#131]
- `Assets/_Project/Scripts/UI/UIManager.cs` - UI management system [Source: docs/game-architecture.md#88]
- `Assets/_Project/Prefabs/UI/UIManager.prefab` - Reusable UI manager [Source: docs/game-architecture.md#89]
- `Assets/_Project/Scripts/UI/GameOverScreen.cs` - Game over screen component
- `Assets/_Project/Scripts/Audio/AudioManager.cs` - Audio management system [Source: docs/game-architecture.md#106]

### Technical Constraints
- GameStateManager must use DontDestroyOnLoad() for persistence across scenes [Source: docs/game-architecture.md#302]
- State transitions must use Unity Events for system decoupling [Source: docs/game-architecture.md#126]
- Screen transitions should use SceneManager.LoadScene() for synchronous loading [Source: docs/game-architecture.md#306]
- Audio transitions should use mixer snapshots for smooth audio changes [Source: docs/game-architecture.md#452]
- Follow Unity lifecycle patterns with initialization in Awake/Start [Source: docs/game-architecture.md#256]

### Game Flow Strategy
- **State Transitions**: Clear transitions between MainMenu → Playing → GameOver → MainMenu
- **Navigation Flow**: Linear navigation with clear "Main Menu" and "Play Again" options
- **State Persistence**: GameStateManager persists across scenes for consistent game flow
- **Audio Integration**: Background music and sound effects enhance state transitions
- **Visual Feedback**: Clear UI indicators for game state and navigation options

### Testing
- **Test Location**: Tests should be created in `Assets/_Project/Tests/EditMode/` for unit tests and `Assets/_Project/Tests/PlayMode/` for integration tests [Source: docs/game-architecture.md#708,714]
- **Test Standards**: Follow Unity Test Framework (NUnit-based) standards as specified in the architecture document [Source: docs/game-architecture.md#696-697]
- **Testing Framework**: Use Unity Test Framework for both edit mode and play mode tests [Source: docs/game-architecture.md#703]
- **Test Coverage**: Aim for 80% coverage for game logic components and 50% coverage for UI components [Source: docs/game-architecture.md#700]
- **Specific Testing Requirements**:
  - Unit test GameStateManager state transitions and validation
  - Integration test screen navigation and UI interactions
  - Performance test memory usage across multiple game sessions
  - Validate state reset functionality for new games
  - Test audio transitions between different game states
  - Verify game over screen displays correct winner information
  - Test navigation buttons functionality (Main Menu, Play Again)
  - Validate no memory leaks after multiple game sessions

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-12 | v1.0 | Story created based on PRD and architecture document | Bob (Scrum Master) |